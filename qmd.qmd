---
format: 
  pdf:
    fig-pos: "H"
lang: es
echo: FALSE
message: FALSE
warning: FALSE
fig-cap-location: top
geometry: 
- top= 25mm
- left= 20mm
- right = 20mm
- bottom = 25mm
---


::: {.center data-latex=""}

\vspace{3cm}

```{r logo facultad, echo=F, include = T, out.width= "60%"}
knitr::include_graphics("logounr.png")
```

\pagenumbering{gobble}

\vspace{5cm}

\Large
**LICENCIATURA EN ESTADÍSTICA**

\vspace{1cm}

\Large
**Guardianes de la galaxia financiera**


\vspace{0.3cm}
\large

*Un análisis mediante modelos lineales generalizados*

\vspace{9cm}

\large

**Autores: Franco Santini - Nicolas Gamboa - Andrés Roncaglia**

**Docentes: Boggio Gabriela - Harvey Guillermina - Costa Victorio**

**2024**
\normalsize
\newpage
\hypersetup{linkcolor = black}
\tableofcontents


\newpage
\pagenumbering{arabic}

:::

\newpage


# Introducción

El fraude con tarjetas de crédito es una de las principales amenazas que sufren los bancos. Con el auge de la tecnología las transacciones digitales facilitaron los traspasos de dinero y los medios de pago electrónicos son algo de cada día, pero junto con las ventajas también vinieron las consecuencias, y es que los métodos de fraude se han vuelto más sofisticados, generando pérdidas significativas a los bancos y afectando la confianza de los usuarios. Actividades como el uso no autorizado de tarjetas, la clonación de datos y transacciones fraudulentas requieren el desarrollo de tecnologías avanzadas para la detección temprana y la prevención.

# Variables:

- `fraud_bool`: Indicadora de si la transacción fue fraude o no

- `income`: Ingreso anual en cuantiles

- `name_email_similarity`: Similitud del nombre en el email y el nombre del solicitante

- `prev_address_months_count`: Es el número de meses que la persona estuvo viviendo en su locacion anterior

- `current_address_months_count`: Es el número de meses que la persona estuvo viviendo en su locacion actual

- `customer_age`: Edad del cliente en décadas

- `days_since_request`: Días desde la solicitud

- `intended_balcon_amount`: Valor de la transferecia inicial para aplicar al credito

- `payment_type`: Tipo del plan de pago 

- `zip_count_4w`: Número de aplicaciónes con el mismo código postal en las últimas 4 semanas

- `velocity_6h`: Es la velocidad del total de solicitudes de transferencias de la tarjeta en las últimas 6 horas

- `velocity_24h`: Es la velocidad del total de solicitudes de transferencias de la tarjeta en las últimas 24 horas

- `velocity_4w`: Es la velocidad del total de solicitudes de transferencias de la tarjeta en las últimas 4 semanas

- `bank_branch_count_8w`: Número total de solicitudes en la seleccionada rama del banco en las últimas 8 semanas

- `date_of_birth_distinct_emails_4w`: Número de emails de aplicantes con la misma fecha de nacimiento en las últimas 4 semanas

- `employment_status`: Estado de empleo del solicitante

- `credit_risk_score`: Score de riesgo de la aplicación

- `email_is_free`: Tipo del dominio del email del aplicante (email pago o gratis)

- `housing_status`: Estado residencial del aplicante

- `phone_home_valid`: Validez del telefono fijo provisto

- `phone_mobile_valid`: Validez del telefono movil provisto

- `bank_months_count`: Antiguedad de la cuenta anterior en meses

- `has_other_cards`: Indicador de si la persona tiene otra tarjeta en el mismo banco

- `proposed_credit_limit`: Crédito limite propuesto por el aplicante

- `foreign_request`: Indicadora de si la solicitud fue hecha en el mismo pais que el banco

- `source`: Fuente online de la aplicación (Internet / app movil) 

- `session_length_in_minutes`: Tiempo de la sesion en la pagina del banco en minutos

- `device_os`: Sistema operativo del dispositivo que hizo la solicitud

- `keep_alive_session`: Indicadora de si el solicitante decidió mantener la sesión iniciada al ingresar

- `device_distinct_emails_8w`: Número de emails distintos en la página del banco desde el mismo dispositivo usado en las últimas 8 semanas

- `device_fraud_count`: Número de solicitudes fraudulentas desde el dispositivo utilizado 

- `month`: Mes en el que fue realizada la solicitud

\newpage

# Análisis descriptivo

```{r, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)
library(glmtoolbox)
library(statmod)
library(pROC)
library(ggforce)
library(caret)

theme_set(theme_bw() + 
            theme(plot.title = element_text(hjust = 0.5),
                  legend.position = "bottom"))

knitr::opts_chunk$set(fig.align = "center")

```


```{r}
data_og <- read.csv("Data/Base_resumida.csv") |> 
  mutate(
    income = factor(income),
    proposed_credit_limit_cat = case_when(proposed_credit_limit == 190 ~ 200,
                                          proposed_credit_limit == 200 ~ 200,
                                          proposed_credit_limit == 210 ~ 200,
                                          proposed_credit_limit == 490 ~ 500,
                                          proposed_credit_limit == 500 ~ 500,
                                          proposed_credit_limit == 510 ~ 500,
                                          proposed_credit_limit == 990 ~ 1000,
                                          proposed_credit_limit == 1000 ~ 1000,
                                          proposed_credit_limit == 1500 ~ 1500,
                                          proposed_credit_limit == 1900 ~ 2000,
                                          proposed_credit_limit == 2000 ~ 2000,
                                          T ~ 2000))

data_og <- data_og |> 
  mutate(
    fraud_bool = factor(fraud_bool),
    proposed_credit_limit_cat = factor(proposed_credit_limit_cat),
    has_other_cards = factor(has_other_cards),
    foreign_request = factor(foreign_request),
    phone_home_valid = factor(phone_home_valid),
    phone_mobile_valid = factor(phone_mobile_valid),
    email_is_free = factor(email_is_free),
    keep_alive_session = factor(keep_alive_session),
    current_address_months_count = case_when(current_address_months_count == -1 ~ NA,
                                              T ~ current_address_months_count),
    bank_months_count = case_when(bank_months_count == -1 ~ NA,
                                              T ~ bank_months_count),
    session_length_in_minutes = case_when(session_length_in_minutes == -1 ~ NA,
                                              T ~ session_length_in_minutes)
  ) |> 
  select(-prev_address_months_count,
         -zip_count_4w,
         -velocity_6h,
         -velocity_4w,
         -days_since_request,
         -intended_balcon_amount,
         -device_fraud_count,
         -bank_branch_count_8w,
         -date_of_birth_distinct_emails_4w)


# Creacion de muestra mas chica -----------------
set.seed(2024)

data_og <- drop_na(data = data_og)

fraude <- data_og |> filter(fraud_bool == 1)
fraude$n <- 1:nrow(fraude)

no_fraude <- data_og |> filter(fraud_bool == 0)
no_fraude$n <- 1:nrow(no_fraude)

proporcion <- sample(seq(0.1, 0.4, by = 0.05), size = 1)
n <- sample(400:700, size = 1)

sel_fraude <- sample(x = fraude$n, size = n*proporcion, replace = F)
sel_nofraude <- sample(x = no_fraude$n, size = n-(n*proporcion), replace = F)

fraude <- fraude[sel_fraude,]
no_fraude <- no_fraude[sel_nofraude,]

data <- rbind(fraude, no_fraude)


# Creacion datos de testeo -----------------

data_resto <- filter(data_og, !(X %in% data$X))

fraude <- data_resto |> filter(fraud_bool == 1)
fraude$n <- 1:nrow(fraude)

no_fraude <- data_resto |> filter(fraud_bool == 0)
no_fraude$n <- 1:nrow(no_fraude)

proporcion <- sample(seq(0.1, 0.4, by = 0.05), size = 1)
n <- floor(n*0.7)

sel_fraude <- sample(x = fraude$n, size = n*proporcion, replace = F)
sel_nofraude <- sample(x = no_fraude$n, size = n-(n*proporcion), replace = F)

fraude <- fraude[sel_fraude,]
no_fraude <- no_fraude[sel_nofraude,]

data_test <- rbind(fraude, no_fraude)


data_test <- data_test |> select(-n, -proposed_credit_limit, -X)



# Saco variables inutiles
data <- data |> select(-n, -proposed_credit_limit, -X)

```



```{r}
#| fig-cap: "Distribución del ingreso anual según si la transacción es fraudulenta o no"

((data |> 
  filter(fraud_bool == 0) |> 
  ggplot() +
  aes(x = income, y = (after_stat(count))/sum(after_stat(count)))+
  geom_bar(color = "black", fill = "#284B63") +
  xlab(label = "Ingreso anual") +
  ylab(label = "Proporción") +
  scale_y_continuous(limits = c(0,0.8)) +
  ggtitle("No fraude")) +
(data |> 
   filter(fraud_bool == 1) |> 
   ggplot() +
   aes(x = income, y = (after_stat(count))/sum(after_stat(count)))+
   geom_bar(color = "black", fill = "#F15946") +
   xlab(label = "Ingreso anual") +
   ylab(label = "Proporción") +
   scale_y_continuous(limits = c(0,0.8)) +
   ggtitle("Fraude"))) + plot_layout(axes = "collect")
```

Se puede observar que las personas que cometieron fraude tienden a tener un ingreso anual registrado mayor. La distribución tiene una mayor asimetría a la izquierda.


```{r}
#| fig-cap: "Distribución del índice de similitud entre en nombre del solicitante y el nombre en el email según si la transacción es fraudulenta o no"

(data |> 
  filter(fraud_bool == 0) |> 
  ggplot() +
  aes(x = name_email_similarity, y = after_stat(density))+
  geom_histogram(bins = 15, color = "black", fill = "#284B63") +
  scale_y_continuous(limits = c(0,5)) +
  xlab(label = "Similitud nombre-email") +
  ylab(label = "Proporción") +
  ggtitle("No fraude")) +
(data |> 
  filter(fraud_bool == 1) |> 
  ggplot() +
  aes(x = name_email_similarity, y = after_stat(density))+
  geom_histogram(bins = 15, color = "black", fill = "#F15946") +
  scale_y_continuous(limits = c(0,5)) +
  xlab(label = "Similitud nombre-email") +
  ylab(label = "Proporción") +
  ggtitle("Fraude")) + plot_layout(axes = "collect")
```

Las transacciones realizadas con emails no muy similares al nombre real de la persona parecen ser más propensas a ser fraudulentas. 



```{r}
#| fig-cap: "Proporción del tipo de pago según si la transacción es fraudulenta o no"

(data |> 
  filter(fraud_bool == 0) |> 
  ggplot() +
  aes(x = payment_type, y = (after_stat(count))/sum(after_stat(count)))+
  geom_bar(color = "black", fill = "#284B63") +
  xlab(label = "Tipo del plan de pago") +
  ylab(label = "Proporción") +
  scale_y_continuous(limits = c(0,0.8)) +
  ggtitle("No fraude")) +
(data |> 
  filter(fraud_bool == 1) |> 
  ggplot() +
  aes(x = payment_type, y = (after_stat(count))/sum(after_stat(count)))+
  geom_bar(color = "black", fill = "#F15946") +
  xlab(label = "Tipo del plan de pago") +
  ylab(label = "Proporción") +
  scale_y_continuous(limits = c(0,0.8)) +
  ggtitle("Fraude")) + plot_layout(axes = "collect")
```

En general, las personas que cometen fraude parecen preferir los métodos de pago "AB" y "AC" por encima del resto, al contrario de las personas que operan de manera legítima que prefieren de igual manera los tipos de pago "AA", "AB" y "AC". Se puede notar también que la forma de pago "AE" no es muy popular.


```{r}
#| fig-cap: "Distribución del límite crediticio propuesto por el solicitante según si la transacción es fraudulenta o no"

(data |> 
  filter(fraud_bool == 0) |> 
  ggplot() +
  aes(x = proposed_credit_limit_cat, y = after_stat(count)/sum(after_stat(count)))+
  geom_bar(color = "black", fill = "#284B63") +
  xlab(label = "Crédito límite propuesto") +
  ylab(label = "Proporción") +
  scale_y_continuous(limits = c(0,0.65))+
  ggtitle("No fraude")) +
(data |> 
  filter(fraud_bool == 1) |> 
  ggplot() +
  aes(x = proposed_credit_limit_cat, y = after_stat(count)/sum(after_stat(count)))+
  geom_bar(color = "black", fill = "#F15946") +
  xlab(label = "Crédito límite propuesto") +
  ylab(label = "Proporción") +
  scale_y_continuous(limits = c(0,0.65))+
  ggtitle("Fraude")) + plot_layout(axes = "collect")
```

Se puede destacar en este gráfico que las personas que cometen fraude son ligeramente más propensas a pedir créditos más altos.


```{r}
#| fig-cap: "Proporción de la tenencia de otra tarjeta en el mismo banco según si la transacción es fraudulenta o no"

(data |> 
   group_by(fraud_bool, has_other_cards) |> 
   summarise(prop = n()) |> 
   mutate(prop = prop/sum(prop)) |> 
  ggplot() +
  aes(x = has_other_cards, y = prop, fill = fraud_bool, group = fraud_bool)+
  geom_bar(color = "black", position = "dodge", stat = "identity") +
  xlab(label = "Tenencia de otras tarjetas") +
  ylab(label = "Proporción") +
  labs(fill = "Fraude") +
  scale_fill_manual(values = c("#284B63","#F15946"),labels = c("No","Si")) +
  scale_x_discrete(labels = c("0" = "No","1" = "Si")) +
  scale_y_continuous(limits = c(0,1)))
```

En cuanto a la tenencia de otra tarjeta en el mismo banco, suele ser común no poseer otra, sin embargo las personas que operan de forma legal se inclinan a tener más de una tarjeta un poco más que aquellos que cometen fraude.

```{r}
#| fig-cap: "Proporción de la locación de la solicitud según si la transacción es fraudulenta o no"

(data |> 
   group_by(fraud_bool, foreign_request) |> 
   summarise(prop = n()) |> 
   mutate(prop = prop/sum(prop)) |> 
  ggplot() +
  aes(x = foreign_request, y = prop, fill = fraud_bool, group = fraud_bool)+
  geom_bar(color = "black", position = "dodge", stat = "identity") +
  xlab(label = "Solicitud extranjera") +
  ylab(label = "Proporción") +
  labs(fill = "Fraude") +
  scale_fill_manual(values = c("#284B63","#F15946"),labels = c("No","Si")) +
  scale_x_discrete(labels = c("0" = "No","1" = "Si")) +
  scale_y_continuous(limits = c(0,1)))
  
```


Se puede observar que las personas que cometen fraude, parecen hacer más solicitudes del exterior que las personas que no cometen fraude, aunque la diferencia parece ser sutil.




```{r}
#| fig-cap: "Proporción del tipo de dominio del email según si la transacción es fraudulenta o no"

(data |> 
   group_by(fraud_bool, email_is_free) |> 
   summarise(prop = n()) |> 
   mutate(prop = prop/sum(prop)) |> 
  ggplot() +
  aes(x = email_is_free, y = prop, fill = fraud_bool, group = fraud_bool)+
  geom_bar(color = "black", position = "dodge", stat = "identity") +
  xlab(label = "Dominio del email") +
  ylab(label = "Proporción") +
  labs(fill = "Fraude") +
  scale_fill_manual(values = c("0" = "#284B63", "1" = "#F15946"),labels = c("No","Si")) +
  scale_x_discrete(labels = c("0" = "Pago","1" = "Gratuito")) +
  scale_y_continuous(limits = c(0,1)))
```

También se puede destacar que las operaciones fraudulentas parecen ser más comunes cuando el dominio del email del solicitante es gratuito que cuando es pago.

```{r}
#| fig-cap: "Distribución del score de riesgo interno según si la transacción es fraudulenta o no"

(data |> 
    filter(fraud_bool == 0) |> 
    ggplot() +
    aes(x = credit_risk_score, y = after_stat(count)/sum(after_stat(count)))+
    geom_histogram(fill = "#284B63", color = "black", bins = 20)+
    scale_y_continuous(limits = c(0, 0.2)) +
    scale_x_continuous(limits = c(-200, 400)) +
    xlab(label = "Score de riesgo crediticio") +
    ylab(label = "Proporción") +
    ggtitle("No fraude")) +
(data |> 
    filter(fraud_bool == 1) |> 
    ggplot() +
    aes(x = credit_risk_score, y = after_stat(count)/sum(after_stat(count)))+
    geom_histogram(fill = "#F15946", color = "black", bins = 20)+
    scale_y_continuous(limits = c(0, 0.2)) +
    scale_x_continuous(limits = c(-200, 400)) +
    xlab(label = "Score de riesgo crediticio") +
    ylab(label = "Proporción") +
    ggtitle("Fraude")) + plot_layout(axes = "collect")
```


La distribución del score de riesgo para las personas que cometen fraude es simétrica y centrada alrededor de 200, mientras que la distribución del score de riesgo para las personas que no cometen fraude parece ser más asimétrica y tener una media menor.




```{r}
#| fig-cap: "Proporción de opciones de inicio de sesión según si la transacción es fraudulenta o no"

(data |> 
   group_by(fraud_bool, keep_alive_session) |> 
   summarise(prop = n()) |> 
   mutate(prop = prop/sum(prop)) |> 
  ggplot() +
  aes(x = keep_alive_session, y = prop, fill = fraud_bool, group = fraud_bool)+
  geom_bar(color = "black", position = "dodge", stat = "identity") +
  xlab(label = "Mantener sesión abierta") +
  ylab(label = "Proporción") +
  labs(fill = "Fraude") +
  scale_fill_manual(values = c("0" = "#284B63", "1" = "#F15946"),labels = c("No","Si")) +
  scale_x_discrete(labels = c("0" = "No","1" = "Si")) +
  scale_y_continuous(limits = c(0,1)))

```


Por lo general, cuando las transacciones son fraudulentas la persona decide no mantener la sesión abierta en la cuenta del banco en mayor proporción que cuando las transacciones son legítimas.

# Modelado

Teniendo todo esto en cuenta se buscó un modelo que ajuste bien a los datos, para esto primero se realizó una selección de variables paso a paso, obteniendo el siguiente modelo:

```{r}

# Modelado ---------------------

model <- glm(fraud_bool ~ ., data = data, family = binomial(link = "logit"), na.action = na.omit)

step(model, direction = "both", 
     trace=0)

modelo_logit <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit_cat + device_os + device_distinct_emails_8w, 
    data = data, 
    family = binomial(link = "logit"), 
    na.action = na.omit)

summary(modelo_logit)
```

```{r}

# Linealidad de las variables ordinales 

data <- data |> 
  mutate(
    income_ord = as.numeric(income),
    proposed_credit_limit_cat_ord = as.numeric(proposed_credit_limit_cat)
  )

model_income_ord <- glm(fraud_bool ~ income_ord + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit_cat + device_os + device_distinct_emails_8w, 
    data = data, 
    family = binomial(link = "logit"), 
    na.action = na.omit)


linealidad <- anova(model_income_ord, modelo_logit)

pchisq(8.2587, 7,lower.tail = F)

# No rechazo H0 por lo que la variable ingreso es lineal

model_cardlimit_ord <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit_cat_ord + device_os + device_distinct_emails_8w, 
    data = data, 
    family = binomial(link = "logit"), 
    na.action = na.omit)

linealidad <- anova(model_cardlimit_ord, modelo_logit)

pchisq(4.8266, 3,lower.tail = F)

# No se rechaza h0 por lo que la variable es lineaaaaal

data <- data |> 
  mutate(
    income = income_ord/10,
    proposed_credit_limit = case_when(proposed_credit_limit_cat_ord == 1 ~ 200,
                                          proposed_credit_limit_cat_ord == 2 ~ 500,
                                          proposed_credit_limit_cat_ord == 3 ~ 1000,
                                          proposed_credit_limit_cat_ord == 4 ~ 1500,
                                          T ~ 2000)
  )
```

```{r}
# Nuevo modelo ajustado con ls variables ordinales

modelo_logit <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w, 
    data = data, 
    family = binomial(link = "logit"), 
    na.action = na.omit)

summary(modelo_logit)

```

```{r}

# Prueba de interacciones dobles de interés

modelo_logit_1 <- glm(fraud_bool ~ income + housing_status +
    phone_home_valid + phone_mobile_valid + has_other_cards +
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:has_other_cards,
    data = data,
    family = binomial(link = "logit"),
    na.action = na.omit)

# summary(modelo_logit_1)
anova(modelo_logit, modelo_logit_1)
pchisq(3.9032, 1, lower.tail = F)


modelo_logit_2 <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid, 
    data = data, 
    family = binomial(link = "logit"), 
    na.action = na.omit)

anova(modelo_logit, modelo_logit_2)



modelo_logit_3 <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid + has_other_cards:phone_mobile_valid, 
    data = data, 
    family = binomial(link = "logit"), 
    na.action = na.omit)

anova(modelo_logit_2, modelo_logit_3)


```


$$
logit(\pi_i) = \beta_0 + \beta_I\cdot I_i + \beta_{H1}\cdot H_{1i} + \beta_{H2}\cdot H_{2i} + \beta_{H3}\cdot H_{3i} + \beta_{H4}\cdot H_{4i} + \beta_{H5}\cdot H_{5i} + \beta_{Ph}\cdot Ph_i + \beta_{Pm}\cdot Pm_i + \beta_C\cdot C_i + \beta_L\cdot L_i + \beta_D\cdot D_i + \beta_E\cdot E_i + \beta_{IPm}\cdot I_i\cdot Pm_i + \beta_{CPm}\cdot C_i\cdot Pm_i 
$$

Se procede a comprobar el enlace:


```{r}
data_enlaces <- data

# Comprobacion enlace logit --------------------
pred.logit<-predict(modelo_logit_3)
data_enlaces$pred.2.logit <- pred.logit*pred.logit

modelo_logit.2 <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid + has_other_cards:phone_mobile_valid + pred.2.logit,
    data = data_enlaces,
    family = binomial(link = "logit"),
    na.action = na.omit)


anova(modelo_logit_3, modelo_logit.2, test="LRT") 
# Este enlace es apropiado

# Comprobacion enlace probit --------------------
modelo_probit <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid + has_other_cards:phone_mobile_valid, data = data, family = binomial(link = "probit"), na.action = na.omit)

pred.probit <- predict(modelo_probit)
data_enlaces$pred.2.probit <- pred.probit*pred.probit

modelo_probit.2 <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid + has_other_cards:phone_mobile_valid + pred.2.probit,
    data = data_enlaces,
    family = binomial(link = "probit"),
    na.action = na.omit)

anova(modelo_probit, modelo_probit.2, test="LRT") 
# Este enlace es apropiado


# Comprobacion enlace cloglog --------------------
modelo_cloglog <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid + has_other_cards:phone_mobile_valid, data = data, family = binomial(link = "cloglog"), na.action = na.omit)

pred.cloglog <- predict(modelo_cloglog)
data_enlaces$pred.2.cloglog <- pred.cloglog*pred.cloglog

modelo_cloglog.2 <- glm(fraud_bool ~ income + housing_status + 
    phone_home_valid + phone_mobile_valid + has_other_cards + 
    proposed_credit_limit + device_os + device_distinct_emails_8w + income:phone_mobile_valid + has_other_cards:phone_mobile_valid +  pred.2.cloglog,
    data = data_enlaces,
    family = binomial(link = "cloglog"),
    na.action = na.omit)

anova(modelo_cloglog, modelo_cloglog.2, test="LRT") 
# Este enlace es apropiado

```

Los tres enlaces son apropiados, por lo tanto nos quedamos con el enlace logit por su facilidad en la interpretación.

```{r}
hltest(modelo_logit_3)
```

### Modelo estimado
$$
logit(\pi_i) = \hat\beta_0 + \hat\beta_I\cdot I_i + \hat\beta_{H1}\cdot H_{1i} + \hat\beta_{H2}\cdot H_{2i} + \hat\beta_{H3}\cdot H_{3i} + \hat\beta_{H4}\cdot H_{4i} + \hat\beta_{H5}\cdot H_{5i} + \hat\beta_{Ph}\cdot Ph_i + \hat\beta_{Pm}\cdot Pm_i + \hat\beta_C\cdot C_i + \hat\beta_L\cdot L_i + \hat\beta_{D1}\cdot D_{1i} + \hat\beta_{D2}\cdot D_{2i} + \hat\beta_{D3}\cdot D_{3i} + \hat\beta_{D4}\cdot D_{4i} + \hat\beta_E\cdot E_i + \hat\beta_{IPm}\cdot I_i\cdot Pm_i + \hat\beta_{CPm}\cdot C_i\cdot Pm_i 
$$

<!-- ### Interpretacion de los coeficientes del modelo -->

<!-- -   $\beta_0$: La log chance de que el cliente cometa fraude cuando las variables cuantitativas valen 0, y las cualitativas se ubican en su categoría de referencia. -->
<!-- -   $\beta_I$: El cambio esperado en la log chance por aumento unitario de la variable ingreso. -->
-   $\hat\beta_{0}=-10.48$
-   $\hat\beta_{I}=8.03$
-   $\hat\beta_{H1}=-1.05$
-   $\hat\beta_{H2}=-1.62$
-   $\hat\beta_{H3}=-17.52$
-   $\hat\beta_{H4}=-2.5$
-   $\hat\beta_{H5}=-17.16$
-   $\hat\beta_{Ph}=-1.31$
-   $\hat\beta_{Pm}=3.21$
-   $\hat\beta_{C}=-18.56$
-   $\hat\beta_{L}=0.001$
-   $\hat\beta_{D1}=1.15$
-   $\hat\beta_{D2}=-1.02$
-   $\hat\beta_{D3}=0.75$
-   $\hat\beta_{D4}=-16.42$
-   $\hat\beta_{E}=4.55$
-   $\hat\beta_{IPm}=-5.99$
-   $\hat\beta_{CPm}=17.84$




## Analisis de residuos

### Evaluación de la componente sistemática


```{r}
# Residuos cuantil
rQ.logit <- qresid(modelo_logit_3)

# Mu estimado
mu_logit <- fitted(modelo_logit_3)

### Gráfico de residuos cuantil vs. probabilidades estimadas (ajuste logit)
G1 <- ggplot(data_enlaces, aes(y = rQ.logit, x = fitted(modelo_probit))) + 
  geom_point(fill = "orange", shape = 21, size = 3, alpha = 0.4) +
  geom_hline(yintercept = 0) + 
  # ylim(-3, 3) + 
  geom_hline(yintercept = -3, linetype = "dashed") + 
  geom_hline(yintercept =  3, linetype = "dashed") +
  labs(title = "Gráfico de residuos cuantil vs. las probabilidades estimadas", x = expression(hat(pi)), y = "Residuos cuantil") +
  theme_minimal()

### Gráfico de residuos cuantil vs. la media estimada (ajuste logit)
G2 <- ggplot(data_enlaces, aes(y = rQ.logit, x = mu_logit)) + 
  geom_point(fill = "orange", shape = 21, size = 3, alpha = 0.4) +
  geom_hline(yintercept = 0) + 
  # ylim(-3, 3) + 
  geom_hline(yintercept = -3, linetype = "dashed") + 
  geom_hline(yintercept =  3, linetype = "dashed") +
  labs(title = "Gráfico de residuos cuantil vs. las medias estimadas", x = expression(hat(mu)), y = "Residuos cuantil") +
  theme_minimal()

G1+G2
```

Dado que no se ve ningún patrón y ningun punto se escapa de las bandas se puede decir que la componente sistematica seleccionada es adecuada.

### Comprobación de la distribución propuesta

```{r}

# Gráfico QQ
ggplot(data_enlaces, aes(sample = rQ.logit)) +
  stat_qq(distribution = qnorm, fill = "orange", shape = 21, size = 3, alpha = 0.4) +
  stat_qq_line() +
  annotate(geom = "label", label = paste("Test de Normalidad Shapiro-Wilks\n p-value:", round(shapiro.test(rQ.logit)$p.value, 2)), x = 0.9, y = -1.5, fill = "lightblue1") +
  labs(title = "Gráfico probabilístico normal con residuos cuantil",  x = "Cuantiles teóricos", y = "Cuantiles de los residuos cuantil") +
  theme_minimal()


```

Viendo el gráfico y el test de Shapiro-Wilks para la normalidad de los errores, se puede concluir que la elección de la distribución de la variable es correcta.


# Interpretaciones


```{r, eval=FALSE}

exp(modelo_logit_3$coefficients["has_other_cards1"])

exp(modelo_logit_3$coefficients["phone_home_valid1"])

exp(modelo_logit_3$coefficients["proposed_credit_limit2000"])

```

La chance de que un cliente comita fraude dado que tiene otra tarjeta en el mismo banco es un 68% menor que un cliente que no tiene, cuando el resto de las variables permanecen constantes.

Del mismo modo, un cliente que proporciono un telefono fijo válido tiene una chance de cometer fraude un 71% menor que uno que proporciono uno no válido, cuando el resto de las variables permanecen constantes.

A medida que el crédito límite propuesto aumenta en mil unidades monetarias, la chance de que un cliente cometa fraude aumenta un 191%, manteniendo el resto de variables fijas. VARIFICAR SI ES LINEAL O NO

Las características de las personas más propensas a cometer fraude (con una probabilidad estimada del 99% aproximadamente) son:

- Ingreso en el decil más alto

- El estado residencial del aplicante es "BA"

- El número de teléfono fijo proporcionado no es válido

- El número de celular proporcionado no es válido

- No tiene otra tarjeta en el mismo banco

- El límite del crédito propuesto fue 2000 euros

- El sistema operativo usado fue macOS

- Se registraron 2 emails distintos en la página del banco desde el mismo dispositivo, en las últimas 8 semanas


Las características de las personas menos propensas a cometer fraude (con una probabilidad estimada de aproximadamente 0%) son:

- Ingreso en el segundo decil

- El estado residencial del aplicante es "BD"

- El número de teléfono fijo proporcionado es válido

- El número de celular proporcionado es válido

- Tiene otra tarjeta en el mismo banco

- El límite del crédito propuesto fue 500 euros

- El sistema operativo usado fue X11

- Se registró un solo email en la página del banco desde dispositivo utilizado, en las últimas 8 semanas































# Capacidad predictiva

```{r}
curva_roc_knn <- roc(response = data$fraud_bool, predictor = fitted(modelo_logit_3), plot = F)

best_knn <- coords(curva_roc_knn, "local maximas")[7,]

data.frame(especificidad = curva_roc_knn$specificities,
           sensibilidad = curva_roc_knn$sensitivities,
           punto_corte = curva_roc_knn$thresholds
          ) |> 
  arrange(especificidad, sensibilidad) |> 
  ggplot() +
  geom_line(aes(x = especificidad, y = sensibilidad)) +
  scale_x_reverse() +
  geom_segment(x = -1, xend=0, y = 0, yend = 1) +
  annotate(x = 0.45, y = 0.75, geom = "text", label = paste("AUC =", round(curva_roc_knn$auc, digits = 4))) +
  geom_mark_ellipse(
    aes(x = best_knn$specificity, y = best_knn$sensitivity,
      label = format(round(as.numeric(best_knn$threshold), digits = 6), scientific = F),
      description = "Punto de corte"), 
    color = "red", 
    expand = 0.01) + 
  labs(x = "Especificidad", y = "Sensibilidad")

```

Se decidió utilizar el mejor punto de corte que maximice la especificidad garantizando una sensibilidad de al menos un 90%, esto para evitar el máximo número de fraudes posibles sin afectar a los clientes legítimos.


```{r}

# Agrego las ordinales
data_test <- data_test |> 
  mutate(
    income = as.numeric(income)/10,
    proposed_credit_limit = case_when(as.numeric(proposed_credit_limit_cat) == 1 ~ 200,
                                          as.numeric(proposed_credit_limit_cat) == 2 ~ 500,
                                          as.numeric(proposed_credit_limit_cat) == 3 ~ 1000,
                                          as.numeric(proposed_credit_limit_cat) == 4 ~ 1500,
                                          T ~ 2000)
  )


prob_pred <- exp(predict(modelo_logit_3, newdata = data_test))/(1+exp(predict(modelo_logit_3, newdata = data_test)))

fraud_pred <- factor(ifelse(prob_pred >= best_knn$threshold, 1, 0), levels = c(0,1))

confusionMatrix(fraud_pred, reference = data_test$fraud_bool, positive = "1")
```


```{r}

curva_roc_knn <- roc(response = data$fraud_bool, predictor = fitted(modelo_logit), plot = F)

best_knn <- coords(curva_roc_knn, "local maximas")[7,]

prob_pred <- exp(predict(modelo_logit, newdata = data_test))/(1+exp(predict(modelo_logit, newdata = data_test)))

fraud_pred <- factor(ifelse(prob_pred >= best_knn$threshold, 1, 0), levels = c(0,1))

confusionMatrix(fraud_pred, reference = data_test$fraud_bool, positive = "1")
```


